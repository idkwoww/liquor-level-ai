<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Liquor Bottle AI Test</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.9.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8/dist/teachablemachine-image.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
    video { border: 2px solid #333; border-radius: 8px; width: 90%; max-width: 400px; }
    #results { margin-top: 20px; text-align: left; display: inline-block; }
    button { margin: 10px; padding: 10px 20px; font-size: 16px; }
  </style>
</head>
<body>
  <h1>Liquor Bottle AI Test</h1>
  <video id="webcam" autoplay playsinline></video><br>
  <button id="startBtn">Start Recording</button>
  <button id="stopBtn" disabled>Stop Recording</button>
  <div id="results"></div>

  <script>
    const URL = "./model/"; // Path to your model
    let model, webcam, ctx;
    let recording = false;
    let bottleSlots = 3; // number of bottles (camera view split into 3 columns)
    let predictionsPerSlot = []; // stores frame-by-frame predictions

    async function init() {
      const modelURL = URL + "model.json";
      const metadataURL = URL + "metadata.json";
      model = await tmImage.load(modelURL, metadataURL);

      // Setup webcam
      webcam = new tmImage.Webcam(400, 300, true); // width, height, flip
      await webcam.setup({ facingMode: "environment" }); 
      await webcam.play();
      document.getElementById("webcam").srcObject = webcam.webcam;

      // init storage
      resetPredictions();
      window.requestAnimationFrame(loop);
    }

    function resetPredictions() {
      predictionsPerSlot = Array.from({ length: bottleSlots }, () => []);
    }

    async function loop() {
      webcam.update();
      if (recording) {
        await analyzeFrame();
      }
      window.requestAnimationFrame(loop);
    }

    async function analyzeFrame() {
      // Split the canvas into slots
      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = webcam.canvas.width;
      tempCanvas.height = webcam.canvas.height;
      const tempCtx = tempCanvas.getContext("2d");
      tempCtx.drawImage(webcam.canvas, 0, 0);

      const slotWidth = tempCanvas.width / bottleSlots;

      for (let i = 0; i < bottleSlots; i++) {
        const imageData = tempCtx.getImageData(i * slotWidth, 0, slotWidth, tempCanvas.height);

        // make sub-canvas for prediction
        const subCanvas = document.createElement("canvas");
        subCanvas.width = slotWidth;
        subCanvas.height = tempCanvas.height;
        subCanvas.getContext("2d").putImageData(imageData, 0, 0);

        const prediction = await model.predict(subCanvas);

        // Save prediction for averaging
        predictionsPerSlot[i].push(prediction);
      }
    }

    function computeFinalResults() {
      const resultsDiv = document.getElementById("results");
      resultsDiv.innerHTML = "<h2>Final Results</h2>";

      predictionsPerSlot.forEach((slotPredictions, i) => {
        if (slotPredictions.length === 0) {
          resultsDiv.innerHTML += `<p>Bottle ${i+1}: No data</p>`;
          return;
        }

        // average across frames
        const classAverages = {};
        slotPredictions.forEach(predArr => {
          predArr.forEach(pred => {
            if (!classAverages[pred.className]) {
              classAverages[pred.className] = [];
            }
            classAverages[pred.className].push(pred.probability);
          });
        });

        // compute mean for each class
        const averaged = Object.entries(classAverages).map(([cls, probs]) => {
          const avg = probs.reduce((a,b) => a+b, 0) / probs.length;
          return { className: cls, probability: avg };
        });

        // find best class
        averaged.sort((a,b) => b.probability - a.probability);
        const best = averaged[0];

        resultsDiv.innerHTML += `<p>Bottle ${i+1}: <b>${best.className}</b> (avg ${(best.probability*100).toFixed(2)}%)</p>`;
      });
    }

    document.getElementById("startBtn").onclick = () => {
      resetPredictions();
      recording = true;
      document.getElementById("startBtn").disabled = true;
      document.getElementById("stopBtn").disabled = false;
    };

    document.getElementById("stopBtn").onclick = () => {
      recording = false;
      computeFinalResults();
      document.getElementById("startBtn").disabled = false;
      document.getElementById("stopBtn").disabled = true;
    };

    init();
  </script>
</body>
</html>
