<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Liquor Bottle AI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 0; padding: 20px; background: #f8f8f8; }
    #webcam-container canvas { width: 90%; max-width: 500px; border-radius: 12px; border: 2px solid #333; margin-top: 10px; }
    #progress-container { margin-top: 20px; max-width: 500px; margin-left: auto; margin-right: auto; text-align: left; }
    .progress-bar { width: 100%; background-color: #ddd; border-radius: 10px; height: 25px; margin-top: 5px; }
    .progress-fill { height: 100%; background-color: #4CAF50; border-radius: 10px; width: 0%; text-align: right; padding-right: 10px; color: white; font-weight: bold; line-height: 25px; }
    select, button { padding: 12px 16px; font-size: 1rem; border-radius: 8px; cursor: pointer; margin-top: 10px; }
  </style>
</head>
<body>
  <h1>Liquor Bottle AI Test</h1>
  <p>Select camera and tap "Start Camera" to scan a bottle.</p>

  <label for="cameraSelect">Camera:</label>
  <select id="cameraSelect">
    <option value="environment" selected>Rear</option>
    <option value="user">Front</option>
  </select>
  <br>
  <button id="startBtn">Start Camera</button>
  <button id="refreshBtn">Refresh Camera</button>

  <div id="webcam-container"></div>
  <div id="progress-container">
    <div class="progress-bar">
      <div class="progress-fill" id="liquidFill">0%</div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8.4/dist/teachablemachine-image.min.js"></script>

  <script>
    const URL = "./model/"; 
    let model, webcam, maxPredictions;
    const classMap = { "Empty": 0, "1/4 Full": 25, "1/2 Full": 50, "3/4 Full": 75, "Full": 100 };
    let rollingPredictions = [];

    async function checkCameraAvailability(facingMode) {
      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return false;
      const devices = await navigator.mediaDevices.enumerateDevices();
      return devices.some(d => d.kind === "videoinput" && d.label.toLowerCase().includes(facingMode === "environment" ? "back" : "front"));
    }

    async function init(facingMode = "environment") {
      const modelURL = URL + "model.json";
      const metadataURL = URL + "metadata.json";

      try { if (!model) model = await tmImage.load(modelURL, metadataURL); } 
      catch (err) { alert("Error loading model: " + err.message); return; }

      maxPredictions = model.getTotalClasses();

      if (webcam) { webcam.stop(); document.getElementById("webcam-container").innerHTML = ""; }

      const available = await checkCameraAvailability(facingMode);
      if (!available) alert(`The ${facingMode === "environment" ? "rear" : "front"} camera is not available.`);

      webcam = new tmImage.Webcam(480, 360, false, { facingMode });
      try { await webcam.setup(); await webcam.play(); } 
      catch (err) { alert("Unable to access selected camera: " + err.message); return; }

      document.getElementById("webcam-container").appendChild(webcam.canvas);
      window.requestAnimationFrame(loop);
    }

    async function loop() {
      webcam.update();
      await predict();
      window.requestAnimationFrame(loop);
    }

    async function predict() {
      const prediction = await model.predict(webcam.canvas);
      // Weighted average
      let total = 0;
      prediction.forEach(p => { total += (classMap[p.className] || 0) * p.probability; });

      // Smooth with rolling average
      rollingPredictions.push(total);
      if (rollingPredictions.length > 5) rollingPredictions.shift();
      const smoothPct = rollingPredictions.reduce((a,b)=>a+b,0) / rollingPredictions.length;

      // Update progress bar
      const fillDiv = document.getElementById("liquidFill");
      fillDiv.style.width = smoothPct + "%";
      fillDiv.textContent = `Liquid: ${smoothPct.toFixed(1)}%`;
    }

    const startBtn = document.getElementById("startBtn");
    const refreshBtn = document.getElementById("refreshBtn");
    const cameraSelect = document.getElementById("cameraSelect");

    startBtn.addEventListener("click", async () => {
      startBtn.disabled = true;
      await init(cameraSelect.value);
      startBtn.disabled = false;
    });

    refreshBtn.addEventListener("click", async () => { await init(cameraSelect.value); });
  </script>
</body>
</html>
